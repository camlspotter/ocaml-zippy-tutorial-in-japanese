再帰で気を付けるべき事
===========================================================================

標準ライブラリの再帰関数を使ったら Stack overflow 出た
======================================================

標準ライブラリの再帰関数はほとんどが末尾再帰呼び出しになっていないので大きいデータを食わせると 
stack が溢れる。比較的小さいデータの場合、非末尾呼び出しのほうがスピードが早いため、そうなっている。

Jane Street Core や OCaml batteries included などの末尾再帰版を使うか自分で末尾再帰版を定義する。

再帰やループで `(^)` など「コピーを伴う連結」は使わない
===========================================================================

`s ^ s'` は 

> `s` と `s'` の長さを合計した長さの文字列をアロケートして、
> そこに `s` と `s'` の内容をコピーする

という操作。再帰やループで文字列をどんどん連結する場合、文字列が長くなればなるほど
どんどん遅くなる。文字列に限らず状態を変更していく再帰やループではコピーコストに
注意しなければならない。

文字列の場合は `Buffer` を使う。こいつは文字列の後ろに文字列を連結していくまさにバッファ
の機能を提供するが、内部で文字列のコピーをできるだけ少なくなるようよろしくやってくれる。

鶏口となるも牛尾となるなかれ: `xs @ [x]` したら負け
===========================================================================

リストの後ろに長さ1のリストを連結するコードはまずおかしいと思って良い。
俺のコードここで `xs @ [x]` してるけどおかしいとは思わないよ？
ならば理由を説明できるはずだ。説明できないのならそれはおかしいのだ。

`xs @ [x]` は `xs` の長さに比例した時間がかかる。これを再帰やループの中で
状態リストを長くしていく操作として使っているならお前はもう死んでいる。
`x :: xs` と `xs @ [x]` の違いは初心者が思っているより深刻だ。

どうしてもリストの後ろに要素を一つ一つ足したいという場合は再帰やループ中では
その逆リストを保持し、 `x :: rev_xs` として更新していく。最後に `List.rev rev_xs` だ。
こんなふうに変数名に `rev` と付けておくと親切かもしれない。
