ラベル付き引数の使い方 (非オプション)
========================================================================

別に好きに使っていいんだけど、次のような時に便利

同じ型の引数を複数取る関数で、その引数の意味を型上にドキュメントとして区別したい
    例えば ``String.blit`` の型を覚えるのは大変だし、間違ったらかなりヤバイので
    型にラベルを付けて嫌でもユーザーに認識させる:

        (* ラベルなし String にある *)
        val blit :     string ->         int ->     string ->         int ->     int -> unit

        (* ラベルあり。 StringLabels に定義されている *)
        val blit : src:string -> src_pos:int -> dst:string -> dst_pos:int -> len:int -> unit

引数の順序を自由に変えてコードを読みやすくしたい場合
    基本的に短く書ける引数を先に書いたほうがプログラムは読みやすい。
    ``List.map`` などのように高階関数引数はダラダラっと長く、最後に一言リスト引数が書いてある
    と、えっと ``map`` の対象になるリストはドコドコドコドコ？となる。ならば入れ替えて
    始めに書けると嬉しい。慣例上、高階関数のラベルを ``f`` にする:

        List.map (fun x ->
            何行でも書けばいいさ
            ...                        えーっと map の対象はどこ？
            何行でも書けばいいさ
          ) xs                         <- あっ、こんなところに

        (* ラベル付き引数で読みやすくした ListLabels.map *)
        ListLabels.map xs ~f:(fun x ->     <- えーと、xs をとにかくナンカスルのね。
            何行でも書けばいいさ
            ...
            何行でも書けばいいさ
          )

オプショナル引数の使い方
========================================================================

オプションラベル付き引数とかオプショナル引数とか言われてる奴。

概要
------------------

``?`` から始まるラベル付き引数はオプショナル。省略できる。
これは GUI ライブラリのような沢山の引数を持ち、かつそのほとんどの規定値(デフォルト)が決まっている、
つまり、オプションラベルが無ければ ``t option`` の型を持つ引数が多い場合にとても便利。

省略できると言っても、OCaml は関数型言語であるので、引数が規定値なので省略されているのか、
それとも partial application で適用されていないのか、区別に難点がある。
そこで OCaml では、もし、型の上でオプションラベル付き引数より後に来るラベルの無い引数が
与えられていた場合、その前に来るオプションラベル付き引数は省略され規定値が使われている
と見なすことにしている。文章で書くと面倒だな。:

    val f : int -> ?foo:bool -> bar:string -> 'a list -> unit

という関数があったとすると、:

    f 3 []

の型は…なんですか？ ``bar:string -> unit`` だ。 ``'a list`` というラベルのない引数が
与えられているので ``?foo:bool`` は省略されているとみなされる。 ``bar:string`` は
ラベルが付いているがオプショナルではないので残る。一方:

    f 3 ~bar:"hello"

では ``'a list`` が与えられていないので ``?foo:bool`` は省略されておらず、まだ引数が
与えられていないと考える。なのでこの式の型は ``?foo:bool -> 'a list -> unit`` 。

うっ、難しい？そりゃそうだ、わざと難しい例を出したんだから。

ラベル付き引数の記法
---------------------

普通に見るのはこんな定義:

    let f x ?(foo=false) ~bar alist = ...

でも、これは次の略記法:

    let f x ?foo:(foo=false) ~bar:bar alist = ...

この記法だと束縛される変数名を変えることができる:

    let f x ?foo:(x=false) ~bar:y alist = ...

とは言え、普通はラベル名と変数名を同じにする略記を使うのがほとんどだろう。
でもこれを知ってないと内部で使用されていないラベル付き引数を警告なしで書くことができない:

    let f x ?foo:_ ~bar:_ alist = ...

デフォルトの無いオプショナル引数
---------------------------------

オプショナル引数は ``?(<ラベル>=<デフォルト>)`` と、規定値を書くことが多いが、この規程値
を書かないこともできる:

    let f x ?foo ~bar alist = match foo with
      | None -> ...
      | Some y -> x + y

この際、オプショナル引数の定義内での型は ``τ option`` になる(上だと ``int option``)。
引数が省略された場合は ``None``、 ``~foo:3`` と書かれた場合は ``Some 3`` が束縛される。
関数自体の型での引数の型と、関数定義内部での引数の型が異なるのに注目。
上の関数の型では ``?foo:int`` になっているが、 ``foo`` は定義内部では ``int option`` になる。

オプショナル引数を持つ関数を受け取る高階関数の扱い
-------------------------------------------------------------------

``f ~l:e`` というラベル付き引数の関数適用、これをコンテクストが不明な場合
コンパイラはどう考えるかという問題。

二つの可能性がある。

* ``l`` という普通の(オプショナルでない)ラベル引数を持つ関数 ``f`` の適用
* ``?l`` というオプショナルなラベル引数を持つ関数 ``f`` の適用

この二つの場合は ``f`` に要求される型が異なる。そのため:

    let h f e = f ~l:e

という関数には二つの異なる型付けが考えられる。これは主型付けが失われることを
意味するので ML の型システムとして大変によろしくない。
元凶はオプショナル引数の適用に、普通のラベル引数の適用と同じシンボルを
使ってしまっていることなのだが、まあそれはそれで便利である。

OCaml ではこの問題を、文脈上ではっきりしないラベル付き引数の
非オプショナル/オプショナルは、全部非オプショナルに倒すということで
解決している。すなはち、上の式では ``~l`` は非オプショナルである:

    let h f e = f ~l:e;;
    val h : (l:'a -> 'b) -> 'a -> 'b = <fun>   (* l の前に ? がついていない *)

ではこのような定義で ``l`` はオプショナルなんだけど、という際にはどうするか。
コンパイラにその旨ヒントの文脈を与える:

    let h (f : (?l:'a -> 'b)) e = f ~l:e;;
    val h : (?l:'a -> 'b) -> 'a -> 'b = <fun>

もしくは、 ``~l`` を使わずに ``?l`` で明示する:

    let h f e = f ?l:(Some e);;
    val h : (?l:'a -> 'b) -> 'a -> 'b = <fun>

まあこういうことからも OCaml は型推論の完全性を目指しておりーとかは
寝言だという事がわかるだろう。

