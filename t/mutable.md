変更可能(mutable)なデータの扱い
====================================

String は mutable
=============================================================

`string` は mutable。コピーせずに let で引き回しても、 alias が作られるだけで実体は同じ。
Alias の片方の中身を変更するともう片方も変化する:

```
let s = "hello world";;
let s' = s;;
s.[0] <- 'x';;
s';;
```

さて `s'` はどうなっているか。

同じ string 定数に見えても実体は違う
=============================================================

`"hello" != "hello"` である。なぜなら上の通り、 string は mutable だから。
定数のつもりでも定数ではない:

```
let s = "hello" in
let s' = "hello" in
s.[0] <- 'x';
s, s'
```

が、:

```
let s = "hello" in
let s' = s in
s.[0] <- 'x';
s, s'
```

に最適化されると、困るだろう。

このことから、同じ文字列がコード中に複数出現した場合、 OCaml ではそれらは
それぞれ別の文字列としてコンパイルされる。 string の mutability を使わない場合
メモリの無駄になるので、特にコード自動生成の場合に、
同じ文字列が大量に作られることがあり、注意。

同じ string 定数を返す関数は全く同じ実体の string 定数を返す
=============================================================

文字列定数について、もう一つ:

```
let f () = "hello"
```

としたとき:

```
f () == f ();;
```

は真。 `f ()` は何やら新規に文字列を作る関数の様に読みたくなるけれども、同じポインタを返してくる。

これは普通のイミュータブルデータの場合と同じ:

```
let f () = [1;2;3] in
let () = assert (f () == f ())

let g x = [x;2;3]
let () = assert (g 1 != g 1)
```

`[1;2;3]` は定数なのでわざわざコピーしない。

ただ問題は文字列が mutable なこと。このため:

```
let s = f () in
s.[4] <- '!'
```

とすると次回から `f ()` を呼ぶと、 `"hello"` ではなく `"hell!"` が返って来る
ようになる。たまに慣れていない人がハマるとかなり困ったバグを引き起す。一回一回新しい文字列を
作る場合は:

```
let f () = String.copy "hello"
```

や `String.create len` を使う。

同じ配列定数を返す関数は全く同じ実体の配列定数を返…さない！！！
=======================================================

ところがだ、:

```
let f () = [|1;2;3|]
```

としたとき:

```
f () != f ();;
```

である。おいおい、実際 `char` の配列である文字列と挙動が違うだろう!!
中身が mutable であるデータ構造はコピーされるのだが、文字列だけは挙動が違うということになっている :-(

String は immutable になる(予定…)
=================================

文字列が mutable だと色々とこのようなデバッグしにくい問題が出て来るので 4.02.0 からは
`string` を immutable にして mutable なバイト列は `bytes` として区別を
していこうということになった。ただしこの区別はまだ過渡的なものでコンパイラに
`-safe-string` を付けないとこの二つの型の区別されないようになっている。


`Array.create` を使ってたらまずバグを疑う
=============================================================

`Array.create` を使う前に、それは `Array.init` の間違いではないか確認すべし。
`Array.create` はもらった値のアドレスをコピーせずに配列全体に埋めるので、
配列の要素の実体は全て同じになる::

```
let r = ref 0
let a = Array.create 10 r
let () = r.(0) := 42
```

この時、 `a` の中身はこのようになっている::

```
[|{contents = 42}; {contents = 42}; {contents = 42}; {contents = 42};
  {contents = 42}; {contents = 42}; {contents = 42}; {contents = 42};
  {contents = 42}; {contents = 42}|]
```

配列を mutable な値を使って `Array.create` で作ってはいけない。
もちろん君が何をやっているのか完全に把握している時は話は別である。


`Hashtbl.t` は mutable
=============================================================

実装が隠蔽されているので忘れがちだが OCaml の幾つかのデータ、
特に Hashtbl.t は mutable で、 pure ではない。
だからスレッドと一緒に使うときは mutex で保護しなければ謎の誤動作やクラッシュが頻発する。

要はスレッドなど使わなければ良い。どうせいまのところ OCaml は parallel GC が無いので
並列(スピード)的に利点は無いし、並行性が欲しければ Lwt などの協調スレッドを使えばよいのだ。
